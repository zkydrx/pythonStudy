# -*- coding: UTF-8 -*-
# 函数式编程
# 函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。
#
# 而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。
#
# 我们首先要搞明白计算机（Computer）和计算（Compute）的概念。
#
# 在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。
#
# 而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。
#
# 对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。
#
# 函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。
#
# 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
#
# Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。

# 高阶函数
# 高阶函数英文叫Higher-order function。什么是高阶函数？我们以实际代码为例子，一步一步深入概念。
#
# 变量可以指向函数
# 以Python内置的求绝对值的函数abs()为例，调用该函数用以下代码：

print(abs(-109))  # => 109
# 但是，如果只写abs呢？
print(abs)  # => <built-in function abs>

# 可见，abs(-10)是函数调用，而abs是函数本身。
#
# 要获得函数调用结果，我们可以把结果赋值给变量：
x = abs(-12)
print(x)  # => 12
# 但是，如果把函数本身赋值给变量呢？
f = abs
print(f)  # => <built-in function abs>
# 结论：函数本身也可以赋值给变量，即：变量可以指向函数。
#
# 如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数？用代码验证一下：
f = abs

print(f(-123))  # => 123


# 成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。
# 函数名也是变量
# 那么函数名是什么呢？函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！
#
# 如果把abs指向其他对象，会有什么情况发生？

# abs = 10
# print(abs(-1)) #=>TypeError: 'int' object is not callable
# 把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！
#
# 当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。
#
# 注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。

# 传入函数
# 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。
#
# 一个最简单的高阶函数：
def add(x, y, f):
    return f(x) + f(y)


# 当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：

print(add(-5, 6, abs))  # =>11
# x = -5
# y = 6
# f = abs
# f(x) + f(y) = abs(-5) + abs(6) #=>11
# return 11

# 编写高阶函数，就是让函数的参数能够接收别的函数。
#
# 小结
# 把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。

import math


def devide(x, y, z, f):
    return f(x) / f(y) + f(z)


print(devide(1, 4, 4, math.sqrt))  # =>2.5
# x = 1
# y = 4
# z = 4
# f = math.sqrt
# f(x)/f(y)+f(z) = math.sqrt(1)/math.sqrt(4)+math.sqrt(3) #=>2.5
# return 2.5

print(devide(1.2342, 2.123, 3.3242, math.floor))  # =>3.5

# x = 1.2342
# y=2.123
# z=3.3242
# f = math.floor
# f(x) / f(y) + f(z) = math.floor(1.2342) / math.floor(2.123) + math.floor(3.3242)  # => 3.5
# return 3.5
